+++
date = '2025-12-02T17:41:26+08:00'
draft = false
title = '古典密码学入门：置换与替换的核心逻辑'
categories = ["ctf-crypto"]
tags = ["古典密码", "栅栏密码", "凯撒密码", "维吉尼亚密码", "置换密码", "替换密码", "Python", "C语言", "CTF密码学"]
series = ["CTF Crypto 系列"]
math = true
cover = "/covers/reimu6.jpg" 
+++
## 引言
hello!欢迎来到咪猫魔法世界~

古典密码作为密码学的启蒙积木，虽无现代密码的数学复杂度，却浓缩了置换与替换两大核心思想——这也是现代分组密码、流密码的底层雏形。

在CTF场景中，古典密码常以送分题形式出现，但极易因细节（大小写、字符过滤、密钥格式）翻车。本文将从密码学定义、算法原理、CTF实战解法、工程实现到常见陷阱，全维度拆解栅栏、凯撒、维吉尼亚三类经典古典密码，同时对比Python与C语言实现的工程差异，为后续学习现代密码学筑牢基础。

---

## 一、古典密码的核心分类与设计原则
古典密码的本质是对明文的字符或比特进行可逆变换，核心分为两类（符合Kerckhoffs原则：密码系统的安全性仅依赖密钥，而非算法本身）：
- 置换密码：仅改变字符排列顺序，不修改字符本身（如栅栏、列置换密码）；
- 替换密码：用新字符替换原字符，保持顺序不变（单表替换：凯撒；多表替换：维吉尼亚）。

两类密码的共性：密钥空间有限，易被暴力破解或统计分析攻破——这也是古典密码仅适用于CTF入门，无法满足现代安全需求的核心原因。

---

## 二、置换密码：栅栏密码
### 2.1 密码学定义与核心原理
栅栏密码是典型的路由置换密码，核心是将明文按固定轨道数（密钥）以之字形排列，再按轨道顺序拼接得到密文。

#### 核心逻辑
设明文为一串字符，轨道数为k（密钥），加密过程分为三步：
1. 构建k个空轨道（字符数组）；
2. 按向下、向上的折返规则，依次将明文字符填入对应轨道；
3. 按轨道顺序拼接所有字符，得到密文。

#### 直观示例（明文：HELLOCRYPTO，k=3）
轨道0：H   L   R   T → HLRT
轨道1：E L O C Y P O → ELOCYPO
轨道2：L   C   O     → LCO
密文：HLRTELOCYPOLCO

### 2.2 CTF实战解法
栅栏密码在CTF中仅有两种出题形式，解法高度固定：
| 场景 | 解法 |
|------|------|
| 已知轨道数k | 直接按轨道折返规则还原明文 |
| 未知轨道数k | 暴力枚举k在2到10之间（超过10无实际加密意义），通过自然语言可读性验证 |
| 变体（列栅栏） | 按列数分组后反转列顺序（如k=2时，每2字符为一组交换位置） |

### 2.3 Python实现
```python
# 栅栏密码核心加解密
def rail_fence_encrypt(text, rails):
    if rails <= 1:
        return text
    rows = [''] * rails
    r, step = 0, 1
    for ch in text:
        rows[r] += ch
        if r == 0:
            step = 1
        elif r == rails - 1:
            step = -1
        r += step
    return ''.join(rows)

def rail_fence_decrypt(cipher, rails):
    if rails <= 1:
        return cipher
    n = len(cipher)
    rail_idx = []
    r, step = 0, 1
    for _ in range(n):
        rail_idx.append(r)
        if r == 0:
            step = 1
        elif r == rails - 1:
            step = -1
        r += step
    
    counts = [rail_idx.count(i) for i in range(rails)]
    rails_str = []
    start = 0
    for c in counts:
        rails_str.append(list(cipher[start:start+c]))
        start += c
    
    res = []
    for rid in rail_idx:
        res.append(rails_str[rid].pop(0))
    return ''.join(res)

# 爆破示例
def rail_fence_brute(cipher):
    res = {}
    for k in range(2, 11):
        res[k] = rail_fence_decrypt(cipher, k)
    return res

# 测试
plain = "HELLOCRYPTO"
cipher = rail_fence_encrypt(plain, 3)
print("加密结果：", cipher)
print("解密结果：", rail_fence_decrypt(cipher, 3))
```

### 2.4 常见陷阱（CTF高频翻车点）
1. 明文含空格或标点：需确认题目要求保留或过滤（多数题目过滤非字母字符）；
2. 轨道数大于等于明文长度：加密后密文与明文一致，无实际意义；
3. 变体识别：部分题目标注栅栏密码但实际为列置换（需按列数分组反转）。

参考资料：[栅栏密码原理与CTF实战](https://blog.csdn.net/Stone__Fly/article/details/53454418)

---

## 三、单表替换密码：凯撒密码
### 3.1 密码学定义与核心原理
凯撒密码是最基础的移位替换密码，核心是将明文字母按固定偏移量k（密钥）循环移位，属于单表替换（所有字符使用同一替换规则）。

#### 核心逻辑（仅考虑大写字母A-Z，A对应0，Z对应25）
- 加密：明文字母按偏移量k向后移动，超出Z则循环到A；
- 解密：密文字母按偏移量k向前移动，超出A则循环到Z。

#### 特殊变体：ROT13
当k=13时，加密与解密规则完全一致（13加13等于26，刚好循环一圈），是CTF中最常见的凯撒变体。

### 3.2 CTF实战解法
凯撒密码的密钥空间仅为26（k在0到25之间），解法极度简单：
1. 暴力枚举所有偏移量，通过自然语言可读性验证（含flag或ctf关键词直接锁定）；
2. 统计字符频率：英文中E出现频率最高，可通过密文高频字符反推偏移量（适用于长明文）。

### 3.3 Python实现
```python
# 凯撒密码核心加解密
def caesar_cipher(text, k, decrypt=False):
    if decrypt:
        k = -k
    res = []
    for ch in text:
        if ch.islower():
            res.append(chr((ord(ch)-97+k)%26+97))
        elif ch.isupper():
            res.append(chr((ord(ch)-65+k)%26+65))
        else:
            res.append(ch)
    return ''.join(res)

# 爆破示例
def caesar_brute(cipher):
    res = {}
    for k in range(26):
        res[k] = caesar_cipher(cipher, k, decrypt=True)
    return res

# 测试
plain = "FLAG{Caesar123}"
cipher = caesar_cipher(plain, 3)
print("加密结果：", cipher)
print("解密结果：", caesar_cipher(cipher, 3, decrypt=True))
```

### 3.4 C语言实现
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void caesar_cipher_c(char *text, int k, int decrypt) {
    if (decrypt) k = -k;
    int len = strlen(text);
    for (int i = 0; i < len; i++) {
        if (islower(text[i])) {
            text[i] = (text[i] - 'a' + k + 26) % 26 + 'a';
        } else if (isupper(text[i])) {
            text[i] = (text[i] - 'A' + k + 26) % 26 + 'A';
        }
    }
}

int main() {
    char cipher[] = "IODJ{Fdhvdu123}";
    caesar_cipher_c(cipher, 3, 1);
    printf("解密结果：%s\n", cipher);
    return 0;
}
```

---

## 四、多表替换密码：维吉尼亚密码
### 4.1 密码学定义与核心原理
维吉尼亚密码是凯撒密码的多表扩展，核心是用关键词（密钥）动态生成偏移量序列，每个字符使用不同的凯撒偏移量，提升单表替换的抗破解性。

#### 核心逻辑
设明文为一串字符，关键词为一组字母（长度为l），则第i个字符的偏移量为关键词第i mod l个字母对应的数值（A对应0，Z对应25）：
- 加密：明文字符按对应偏移量向后移动；
- 解密：密文字符按对应偏移量向前移动。

### 4.2 CTF实战解法
| 场景 | 解法 |
|------|------|
| 已知关键词 | 按关键词长度循环生成偏移量，逐字符解密 |
| 未知关键词（短） | 爆破关键词长度（2到8）+ 单表频率分析 |
| 未知关键词（长） | 用Kasiski检验或Friedman测试计算关键词长度，再逐表频率分析 |

### 4.3 Python实现
```python
# 维吉尼亚密码核心加解密
def vigenere_cipher(text, key, decrypt=False):
    key = ''.join([c.upper() for c in key if c.isalpha()])
    if not key:
        return text
    key_len = len(key)
    res = []
    j = 0
    for ch in text:
        if ch.isalpha():
            base = ord('A') if ch.isupper() else ord('a')
            shift = ord(key[j % key_len]) - ord('A')
            if decrypt:
                shift = -shift
            res.append(chr((ord(ch)-base+shift)%26+base))
            j += 1
        else:
            res.append(ch)
    return ''.join(res)

# 测试
plain = "FLAG{Vigenere123}"
key = "CRYPTO"
cipher = vigenere_cipher(plain, key)
print("加密结果：", cipher)
print("解密结果：", vigenere_cipher(cipher, key, decrypt=True))
```

### 4.4 常见陷阱
1. 关键词含非字母字符：需先过滤（仅保留字母）；
2. 大小写混合：建议统一转为大写或小写后处理；
3. 明文长度小于关键词长度：关键词截断后使用。

参考资料：[维吉尼亚密码原理与实现](https://blog.csdn.net/qq_42650988/article/details/104342775)

---

## 五、Python vs C：古典密码实现的工程对比
| 对比维度 | Python 实现特点 | C 语言实现特点 |
|----------|----------------|----------------|
| 字符串处理 | 不可变字符串，切片/拼接便捷，无需手动管理内存 | 字符数组加\0结尾，易出现越界或内存泄漏 |
| 字符运算 | ord/chr 封装ASCII转换，模运算直观 | 手动对齐ASCII码（ch-'A'），需处理负数 |
| 代码效率 | 开发效率高，适合快速试错/爆破 | 执行效率高，适合嵌入式/底层实现 |
| 调试成本 | print/Jupyter 快速调试 | 需结合gdb或valgrind排查内存问题 |
| 依赖管理 | 标准库全覆盖，第三方库安装便捷 | 仅依赖系统头文件，无外部依赖 |
| CTF适用场景 | 批量爆破、脚本化解题、快速验证思路 | 分析题目提供的C程序、底层漏洞挖掘 |
| 常见错误 | 字节/字符串编码混淆、索引越界 | 缓冲区溢出、scanf读入截断、空指针访问 |

### 工程化建议
- 学习阶段：Python写思路，C写理解——先用Python快速验证密码算法逻辑，再用C实现以理解底层内存/字符操作；
- CTF实战：优先用Python编写爆破脚本，效率比C高10倍以上；
- 工程落地：核心加密逻辑用C实现（性能），上层控制逻辑用Python实现（便捷）。

---

## 六、学习总结与后续规划
古典密码虽简单，却承载了密码学的核心思维：
1. Kerckhoffs原则：安全性仅依赖密钥（古典密码因密钥空间小，无法满足现代需求）；
2. 对称加密雏形：置换加替换是AES、DES的核心操作（字节代换、行移位、列混合）；
3. 暴力破解思想：密钥空间有限时，枚举是最直接的破解手段。

### 后续规划（CTF进阶方向）
1. 封装古典密码自动求解工具：输入密文，自动识别密码类型，爆破输出候选明文；
2. 学习古典密码的进阶变体：仿射密码、Playfair密码、希尔密码；
3. 衔接现代密码学：从古典密码的手动置换/替换，过渡到AES的轮函数自动变换。

如果你也在深耕CTF Crypto方向，欢迎来咪喵魔法部交流～一起从古典密码的小魔法，解锁现代密码学的大工程。
```