<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CTF Crypto 系列 on SWEET&#39;S BLOG</title>
    <link>http://localhost:1336/series/ctf-crypto-%E7%B3%BB%E5%88%97/</link>
    <description>Recent content from SWEET&#39;S BLOG</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    
    <managingEditor>1401617591@qq.com (sweet)</managingEditor>
    <webMaster>1401617591@qq.com (sweet)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Sun, 21 Dec 2025 14:00:00 +0800</lastBuildDate>
    
    
    <atom:link href="http://localhost:1336/series/ctf-crypto-%E7%B3%BB%E5%88%97/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>RSA基础与大数分解（含多种类型exp）🐾</title>
      <link>http://localhost:1336/post/rsa%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Sun, 21 Dec 2025 14:00:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/rsa%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3/</guid>
      <description>
        <![CDATA[<h1>RSA基础与大数分解（含多种类型exp）🐾</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎回到咪猫魔法世界~ 🐾✨</p>
<p>前面啃完数论基础和CryptoHack入门题，这篇聚焦RSA核心——它是1977年由Ron Rivest、Adi Shamir和Leonard Adleman提出的非对称加密算法，本质是数论知识点（欧拉函数、模逆元、大质数判断）的拼接。另外我在这篇文章中还对 RSA安全基石、更多CTF攻击类型、实际应用场景和实战工具等进行了整合，让大家通过这一篇文章就能够大概了解多种 RSA 的“原理+实战+拓展”实际应用~</p>
<hr>
<h2 id="一rsa加密算法基础">
<a class="header-anchor" href="#%e4%b8%80rsa%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e5%9f%ba%e7%a1%80"></a>
一、RSA加密算法基础
</h2><h3 id="11-核心定义与安全基石">
<a class="header-anchor" href="#11-%e6%a0%b8%e5%bf%83%e5%ae%9a%e4%b9%89%e4%b8%8e%e5%ae%89%e5%85%a8%e5%9f%ba%e7%9f%b3"></a>
1.1 核心定义与安全基石
</h3><p>RSA是非对称加密算法的经典代表，加密和解密使用不同密钥，安全性完全建立在“大数分解难题”之上。</p>
<ul>
<li>正向计算容易：两个大质数p、q相乘得到n，操作简单高效；</li>
<li>逆向推导极难：已知n，想分解出p和q，以当前经典计算能力需数百年甚至更久，这构成了RSA的安全防线。</li>
</ul>
<h3 id="12-rsa-的核心流程">
<a class="header-anchor" href="#12-rsa-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b"></a>
1.2 RSA 的核心流程
</h3><h4 id="121-密钥生成">
<a class="header-anchor" href="#121-%e5%af%86%e9%92%a5%e7%94%9f%e6%88%90"></a>
1.2.1 密钥生成
</h4><ol>
<li>选两个不相等大质数p、q（CTF中常见1024/2048位，实际推荐2048位以上）；</li>
<li>算模数$n = p \times q$（公钥/私钥共用核心模数）；</li>
<li>算欧拉函数$\phi(n) = (p-1)(q-1)$（若n为多素数乘积，$\phi(n)$为各素数减1的乘积）；</li>
<li>选公钥e：满足$1 < e < \phi(n)$且$\gcd(e,\phi(n))=1$，常用65537（费马素数），避免用3/17等小指数；</li>
<li>算私钥d：d是e的模逆元，即$e \times d \equiv 1 \pmod{\phi(n)}$，可通过多种方法求解（如下文方法）。</li>
</ol>
<p>✅ 最终：公钥$(e,n)$公开（用于加密/验签），私钥$(d,n)$保密（用于解密/签名）。</p>
<h4 id="122-加密解密">
<a class="header-anchor" href="#122-%e5%8a%a0%e5%af%86%e8%a7%a3%e5%af%86"></a>
1.2.2 加密&amp;解密
</h4><ul>
<li>加密（公钥）：$c = m^e \pmod{n}$（m为明文，需满足$m < n$，否则需分组或填充）；</li>
<li>解密（私钥）：$m = c^d \pmod{n}$；</li>
<li>原理支撑：欧拉定理（$\gcd(m,n)=1$时，$m^{\phi(n)} \equiv 1 \pmod{n}$），因$e \times d = k \times \phi(n) + 1$，故$m^{e \times d} \equiv m \pmod{n}$。</li>
</ul>
<h4 id="123-核心特性与应用场景">
<a class="header-anchor" href="#123-%e6%a0%b8%e5%bf%83%e7%89%b9%e6%80%a7%e4%b8%8e%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af"></a>
1.2.3 核心特性与应用场景
</h4><ul>
<li>非对称性：公钥加密只能私钥解密，私钥签名只能公钥验签，是应用核心；</li>
<li>典型用途：
<ol>
<li>密钥分发：HTTPS/SSL中，浏览器用服务器公钥加密临时会话密钥，后续用对称加密通信；</li>
<li>身份验证：SSH免密登录，本地私钥应答服务器公钥挑战；</li>
<li>数字签名：软件发布者用私钥签名哈希值，用户用公钥验签，确保软件未篡改。</li>
</ol>
</li>
</ul>
<h4 id="124-模逆元的三种求解方法">
<a class="header-anchor" href="#124-%e6%a8%a1%e9%80%86%e5%85%83%e7%9a%84%e4%b8%89%e7%a7%8d%e6%b1%82%e8%a7%a3%e6%96%b9%e6%b3%95"></a>
1.2.4 模逆元的三种求解方法
</h4><p>除了扩展欧几里得算法，模逆元还有两种常用求法，适配不同场景：</p>
        
        <hr><p>本文2025-12-21首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-21</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>信安数学基础学习与练习</title>
      <link>http://localhost:1336/post/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 15 Dec 2025 14:00:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</guid>
      <description>
        <![CDATA[<h1>信安数学基础学习与练习</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎来到咪猫魔法世界~ 🐾✨</p>
<p>本篇内容参考了不少CSDN上的优质文章与笔记，我把核心知识点都提炼成了易懂的短句（可能略有偏差，但足够贴合初学理解）。其中包含具体示例、算法解析、构造方法的优质资料也都整合在文中啦，希望能给同样初学的师傅们一些帮助（若有理解上的偏差也希望师傅们及时指出！）~~o( =∩ω∩= )m</p>
<hr>
<h2 id="一信安数学基础学习">
<a class="header-anchor" href="#%e4%b8%80%e4%bf%a1%e5%ae%89%e6%95%b0%e5%ad%a6%e5%9f%ba%e7%a1%80%e5%ad%a6%e4%b9%a0"></a>
一、信安数学基础学习
</h2><h3 id="1-整除欧几里得除法与素数基本定理">
<a class="header-anchor" href="#1-%e6%95%b4%e9%99%a4%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e9%99%a4%e6%b3%95%e4%b8%8e%e7%b4%a0%e6%95%b0%e5%9f%ba%e6%9c%ac%e5%ae%9a%e7%90%86"></a>
1. 整除、欧几里得除法与素数基本定理
</h3><ul>
<li>
<p><strong>整除</strong>：若a÷b=c无余数，则称b整除a（记为b∣a），商为c。</p>
</li>
<li>
<p>关键性质：</p>
<ul>
<li>传递性：如12能被6整除、6能被3整除，则12必能被3整除；</li>
<li>线性组合：如6能整除12和18，则6也能整除12×2+18×3=78（倍数的线性组合仍为倍数）。</li>
</ul>
</li>
<li>
<p><strong>欧几里得除法（带余除法）</strong>：a÷b=c余d（0&lt;d&lt;b），其中c和d是唯一确定的。</p>
</li>
<li>
<p>核心作用：是求最大公约数、解同余方程的基础，先固定除法的“商余关系”。</p>
</li>
<li>
<p><strong>最大公约数(gcd)与欧几里得算法(辗转相除法)</strong>：</p>
<ul>
<li>
<p>gcd定义：能同时整除a和b的最大整数，如gcd(198,252)=18；</p>
</li>
<li>
<p>特殊情况：若gcd(a,b)=1，则a和b互素（如4和5，仅1能同时整除）；</p>
</li>
<li>
<p>欧几里得算法：大数÷小数得余数，再用原除数÷余数，重复至余数为0，最后一个非零余数即为gcd；</p>
</li>
<li>
<p>示例：计算gcd(252,198)</p>
<p>①252÷198=1余54；</p>
<p>②198÷54=3余36；</p>
<p>③54÷36=1余18；</p>
<p>④36÷18=2余0</p>
<p>→ 最终gcd=18。</p>
</li>
</ul>
</li>
<li>
<p><strong>扩展欧几里得算法</strong>：</p>
<ul>
<li>核心能力：除求gcd(a,b)外，还能找到整数x、y满足a×x + b×y = gcd(a,b)；</li>
<li>计算方法：回代法——先通过欧几里得算法求gcd，再从最后一步反向回代，推导出满足等式的x、y；</li>
<li>注意点：若x为负数，需累加模数至x为正；</li>
<li>核心应用：求模逆元——若a和m互素（gcd(a,m)=1），可找到x使a×x ≡1 mod m（x即为a的逆元，如2×3=6≡1 mod5，3是2的逆元），是密码学解密的关键。</li>
</ul>
</li>
<li>
<p><strong>素数基本定理</strong>：</p>
<ul>
<li>核心结论：当x→∞时，不大于x的素数个数π(x)与x/lnx渐近等价（比值趋近于1）；</li>
<li>应用：用于计算欧拉函数、判断RSA等密码算法的安全性（依赖大素数难分解的特性）。</li>
</ul>
</li>
</ul>
<h3 id="2-同余与剩余系">
<a class="header-anchor" href="#2-%e5%90%8c%e4%bd%99%e4%b8%8e%e5%89%a9%e4%bd%99%e7%b3%bb"></a>
2. 同余与剩余系
</h3><ul>
<li>
<p><strong>同余</strong>：</p>
<ul>
<li>定义：若a和b除以m的余数相同，则称a≡b(mod m)（如17≡2 mod5），且a-b能被m整除；</li>
<li>核心性质：
<ul>
<li>加减乘不变：如3≡8 mod5、4≡9 mod5，则3+4=7≡8+9=17 mod5，3×4=12≡8×9=72 mod5；</li>
<li>消去律（有条件）：如2×3≡2×8 mod5，因2和5互素，可消去2得3≡8 mod5。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>剩余系</strong>：</p>
<ul>
<li>完全剩余系：除以m能覆盖0~m-1所有余数的一组数（无遗漏、无重复）；</li>
<li>简化剩余系：从完全剩余系中筛选出与m互素的数，其个数为欧拉函数φ(m)；</li>
<li>示例：模6的完全剩余系为{0,1,2,3,4,5}，简化剩余系为{1,5}，故φ(6)=2。</li>
</ul>
</li>
</ul>
<h3 id="3-欧拉函数欧拉定理与费马小定理">
<a class="header-anchor" href="#3-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86%e4%b8%8e%e8%b4%b9%e9%a9%ac%e5%b0%8f%e5%ae%9a%e7%90%86"></a>
3. 欧拉函数、欧拉定理与费马小定理
</h3><ul>
<li>
<p><strong>欧拉函数φ(m)</strong>：1~m中与m互素的整数个数，如φ(6)=2。</p>
        
        <hr><p>本文2025-12-15首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-15</p>]]>
      </description>
      
        <category>ctf-math</category>
      
    </item>
    
    

    <item>
      <title>哈希算法与文件隐写基础</title>
      <link>http://localhost:1336/post/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E6%96%87%E4%BB%B6%E9%9A%90%E5%86%99%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 08 Dec 2025 14:00:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E6%96%87%E4%BB%B6%E9%9A%90%E5%86%99%E5%9F%BA%E7%A1%80/</guid>
      <description>
        <![CDATA[<h1>哈希算法与文件隐写基础</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎来到咪猫魔法世界~ 🐾✨</p>
<p>在 CTF 的 Crypto/Misc 里，<strong>哈希像“给数据按下的指纹印章”</strong>：你拿着印章（算法）一盖，谁来都能复现同一个指纹；而<strong>文件隐写</strong>更像“把小纸条塞进字节夹层里”——文件表面看着正常，里面却藏着另一份故事。
这两类题的共同点是：<strong>不靠玄学，靠流程</strong>。你只要会“看懂它是什么、再决定怎么下手”，分数就会自己跑过来（O.o）✨</p>
<hr>
<h2 id="一关于哈希--加密--编码">
<a class="header-anchor" href="#%e4%b8%80%e5%85%b3%e4%ba%8e%e5%93%88%e5%b8%8c--%e5%8a%a0%e5%af%86--%e7%bc%96%e7%a0%81"></a>
一、关于哈希 / 加密 / 编码
</h2><p>很多新手🐱栽的第一个坑，就是把这三者混成一锅粥（比如我曾经就在做ER图的时候写了这样一个词：“加密后的密文”，当时我们项目指导老师笑的嘴角就没压下来过555）。那么我们现在一起来理理这三者之间的关系，相信看完之后你会对三者之间的区别有一个更加清新的认识。</p>
<table>
  <thead>
      <tr>
          <th>对比维度</th>
          <th>哈希（Hash）</th>
          <th>加密（Encryption）</th>
          <th>编码（Encoding）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>能不能还原</td>
          <td><strong>理论上不可逆</strong>（只能撞/爆破/查表）</td>
          <td><strong>可逆</strong>（有密钥就能解）</td>
          <td><strong>可逆</strong>（公开规则就能解）</td>
      </tr>
      <tr>
          <td>主要目的</td>
          <td>完整性校验、唯一标识、指纹对比</td>
          <td>保密通信、保护内容</td>
          <td>适配传输/存储（显示、协议、字符集）</td>
      </tr>
      <tr>
          <td>常见例子</td>
          <td>MD5、SHA-1、SHA-256、CRC32</td>
          <td>AES、RSA</td>
          <td>Base64、URL Encode、UTF-8</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>咪猫口诀：<strong>哈希“变不回去”，加密“有钥匙回去”，编码“大家都能回去”。</strong> 🐾</p>
</blockquote>
<p>这里要补一层更“比赛友好”的理解：
CTF 里说“破解哈希”，大多数时候其实不是从哈希值反推出原文（那是做梦），而是——<strong>你猜一堆可能的原文，把它们都盖一遍指纹，看看谁对上了</strong>。</p>
<hr>
<h2 id="二哈希到底强在哪里也脆在哪里">
<a class="header-anchor" href="#%e4%ba%8c%e5%93%88%e5%b8%8c%e5%88%b0%e5%ba%95%e5%bc%ba%e5%9c%a8%e5%93%aa%e9%87%8c%e4%b9%9f%e8%84%86%e5%9c%a8%e5%93%aa%e9%87%8c"></a>
二、哈希到底强在哪里（也脆在哪里）
</h2><p>哈希函数的理想目标是：输入再长再乱，我都能稳定给你一个固定长度的“指纹”。而且这个指纹要尽量满足三件事（CTF 和现实都爱考）：</p>
<ol>
<li>
<p><strong>固定长度</strong>：不管你喂它 1 个字符还是 1G 文件，输出长度都固定。</p>
</li>
<li>
<p><strong>雪崩效应</strong>：输入哪怕只改一个字节，输出也会像翻桌一样完全不一样。</p>
</li>
<li>
<p><strong>抗碰撞/抗预像（理想状态）</strong>：</p>
<ul>
<li><strong>碰撞</strong>：找两个不同输入，输出却相同（<code>A != B</code> 但 <code>H(A)=H(B)</code>）。</li>
<li><strong>预像</strong>：给你一个哈希值，让你找到一个输入能产生它（给“指纹”找“手指”）。</li>
</ul>
</li>
</ol>
<p>现实是：算法有“年纪”和“命运”。MD5、SHA-1 都已经不再适合作为安全用途（尤其是防碰撞），但它们在 CTF 里依然很常见——因为题目想考的是<strong>你的识别与流程</strong>，不是真让你写论文。</p>
<p>（SHA 系列的标准可以看 NIST 的 Secure Hash Standard：FIPS 180-4。 (<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf?utm_source=chatgpt.com" title="Secure Hash Standard (SHS) - NIST">NIST出版物</a>)；MD5 的规范可以看 RFC 1321。 (<a href="https://www.rfc-editor.org/rfc/rfc1321?utm_source=chatgpt.com" title="RFC 1321: The MD5 Message-Digest Algorithm">RFC 编辑器</a>)）</p>
        
        <hr><p>本文2025-12-08首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-08</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>CyberChef：编码基础与可视化解密</title>
      <link>http://localhost:1336/post/%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Thu, 04 Dec 2025 14:00:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A7%A3%E5%AF%86/</guid>
      <description>
        <![CDATA[<h1>CyberChef：编码基础与可视化解密</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello! 欢迎来到咪猫魔法世界 🐾</p>
<p>在 CTF Crypto 里，<strong>编码是“字节与人类语言之间的通用咒语”</strong>：所有明文、密文最终都会以字节（bytes）形式存储与传输。理解编码的标准化规则，就能更快拆解题目外层的数据伪装。
而 <strong>CyberChef</strong> 是咪猫的炼金台：拖拽模块、实时出结果，非常适合用来验证你对“这层到底是不是编码”的判断。</p>
<hr>
<h2 id="一编码-vs-加密">
<a class="header-anchor" href="#%e4%b8%80%e7%bc%96%e7%a0%81-vs-%e5%8a%a0%e5%af%86"></a>
一、编码 vs 加密
</h2><p>编码和加密经常被新手混淆，但它们的目标完全不同。<strong>编码遵循公开的标准规则</strong>，解决的是数据表示与传输问题，所以本身不提供保密性；<strong>加密依赖密钥进行变换</strong>，核心是隐藏内容，没有密钥就难以合法还原。</p>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>核心特征</th>
          <th>关键区别</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>编码（Encoding）</td>
          <td>公开标准化规则，解决表示/传输</td>
          <td>无保密性，按规则可还原</td>
      </tr>
      <tr>
          <td>加密（Encryption）</td>
          <td>依赖密钥的变换，隐藏内容</td>
          <td>无密钥难以还原</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>咪猫口诀：<strong>编码是能读懂，加密是读不懂。</strong></p>
</blockquote>
<blockquote>
<p>小提示：CTF 常把“编码 + 加密”叠加出题，一般顺序是<strong>先解编码，再解加密</strong>。</p>
</blockquote>
<hr>
<h2 id="二ctf-最核心的三类编码">
<a class="header-anchor" href="#%e4%ba%8cctf-%e6%9c%80%e6%a0%b8%e5%bf%83%e7%9a%84%e4%b8%89%e7%b1%bb%e7%bc%96%e7%a0%81"></a>
二、CTF 最核心的三类编码
</h2><h3 id="21-字符编码ascii--utf-8--gbk">
<a class="header-anchor" href="#21-%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81ascii--utf-8--gbk"></a>
2.1 字符编码：ASCII / UTF-8 / GBK
</h3><p>字符编码解决的是<strong>字符与字节之间的标准化映射</strong>，这是所有编码题的地基。ASCII 覆盖英文、数字和基础符号，是很多编码的基础；UTF-8 是互联网主流标准（RFC 3629），兼容 ASCII，多语言场景最常见；GBK 则更常出现在 Windows 环境中，尤其是中文相关的数据。</p>
<p>在 CTF 里我们真正需要记住的不是“背表”，而是一个判断：<strong>同一段字节用错编码会乱码</strong>。例如 GBK 的中文如果按 UTF-8 去解释，就可能出现乱码。遇到这种情况，CyberChef 里用 <code>Decode text</code> 切换编码选项，往往就能直接还原。</p>
<table>
  <thead>
      <tr>
          <th>编码</th>
          <th>权威标准</th>
          <th style="text-align: right">字节占用</th>
          <th>CTF 常见关注点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ASCII</td>
          <td>ANSI X3.4-1968</td>
          <td style="text-align: right">1 字节</td>
          <td>基础文本、协议字段</td>
      </tr>
      <tr>
          <td>UTF-8</td>
          <td>RFC 3629</td>
          <td style="text-align: right">1–4 字节</td>
          <td>主流；中文通常 3 字节/字</td>
      </tr>
      <tr>
          <td>GBK</td>
          <td>GB 18030 相关扩展</td>
          <td style="text-align: right">1–2 字节</td>
          <td>Windows 常见；中文通常 2 字节/字</td>
      </tr>
  </tbody>
</table>
<h3 id="22-base-家族base64--base32--base85">
<a class="header-anchor" href="#22-base-%e5%ae%b6%e6%97%8fbase64--base32--base85"></a>
2.2 Base 家族：Base64 / Base32 / Base85
</h3><p>Base 类编码的定位很明确：把二进制数据变成可打印字符，方便在文本通道传输。其中 Base64 与 Base32 可参考 RFC 4648，标准化程度更高。CTF 场景里，Base64 是绝对高频：你会经常遇到“看起来像一串字母数字、末尾带 <code>=</code>”的字符串，它很可能就是 Base64。</p>
        
        <hr><p>本文2025-12-04首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-04</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>古典密码学入门：置换与替换的核心逻辑</title>
      <link>http://localhost:1336/post/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E7%9A%84%E6%8E%A2%E7%B4%A2/</link>
      <pubDate>Tue, 02 Dec 2025 17:41:26 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E7%9A%84%E6%8E%A2%E7%B4%A2/</guid>
      <description>
        <![CDATA[<h1>古典密码学入门：置换与替换的核心逻辑</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello!欢迎来到咪猫魔法世界~</p>
<p>古典密码作为密码学的启蒙积木，虽无现代密码的数学复杂度，却浓缩了置换与替换两大核心思想——这也是现代分组密码、流密码的底层雏形。</p>
<p>在CTF场景中，古典密码常以送分题形式出现，但极易因细节（大小写、字符过滤、密钥格式）翻车。本文将从密码学定义、算法原理、CTF实战解法、工程实现到常见陷阱，全维度拆解栅栏、凯撒、维吉尼亚三类经典古典密码，同时对比Python与C语言实现的工程差异，为后续学习现代密码学筑牢基础。</p>
<hr>
<h2 id="一古典密码的核心分类与设计原则">
<a class="header-anchor" href="#%e4%b8%80%e5%8f%a4%e5%85%b8%e5%af%86%e7%a0%81%e7%9a%84%e6%a0%b8%e5%bf%83%e5%88%86%e7%b1%bb%e4%b8%8e%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99"></a>
一、古典密码的核心分类与设计原则
</h2><p>古典密码的本质是对明文的字符或比特进行可逆变换，核心分为两类（符合Kerckhoffs原则：密码系统的安全性仅依赖密钥，而非算法本身）：</p>
<ul>
<li>置换密码：仅改变字符排列顺序，不修改字符本身（如栅栏、列置换密码）；</li>
<li>替换密码：用新字符替换原字符，保持顺序不变（单表替换：凯撒；多表替换：维吉尼亚）。</li>
</ul>
<p>两类密码的共性：密钥空间有限，易被暴力破解或统计分析攻破——这也是古典密码仅适用于CTF入门，无法满足现代安全需求的核心原因。</p>
<hr>
<h2 id="二置换密码栅栏密码">
<a class="header-anchor" href="#%e4%ba%8c%e7%bd%ae%e6%8d%a2%e5%af%86%e7%a0%81%e6%a0%85%e6%a0%8f%e5%af%86%e7%a0%81"></a>
二、置换密码：栅栏密码
</h2><h3 id="21-密码学定义与核心原理">
<a class="header-anchor" href="#21-%e5%af%86%e7%a0%81%e5%ad%a6%e5%ae%9a%e4%b9%89%e4%b8%8e%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86"></a>
2.1 密码学定义与核心原理
</h3><p>栅栏密码是典型的路由置换密码，核心是将明文按固定轨道数（密钥）以之字形排列，再按轨道顺序拼接得到密文。</p>
<h4 id="核心逻辑">
<a class="header-anchor" href="#%e6%a0%b8%e5%bf%83%e9%80%bb%e8%be%91"></a>
核心逻辑
</h4><p>设明文为一串字符，轨道数为k（密钥），加密过程分为三步：</p>
<ol>
<li>构建k个空轨道（字符数组）；</li>
<li>按向下、向上的折返规则，依次将明文字符填入对应轨道；</li>
<li>按轨道顺序拼接所有字符，得到密文。</li>
</ol>
<h4 id="直观示例明文hellocryptok3">
<a class="header-anchor" href="#%e7%9b%b4%e8%a7%82%e7%a4%ba%e4%be%8b%e6%98%8e%e6%96%87hellocryptok3"></a>
直观示例（明文：HELLOCRYPTO，k=3）
</h4><p>轨道0：H   L   R   T → HLRT
轨道1：E L O C Y P O → ELOCYPO
轨道2：L   C   O     → LCO
密文：HLRTELOCYPOLCO</p>
<h3 id="22-ctf实战解法">
<a class="header-anchor" href="#22-ctf%e5%ae%9e%e6%88%98%e8%a7%a3%e6%b3%95"></a>
2.2 CTF实战解法
</h3><p>栅栏密码在CTF中仅有两种出题形式，解法高度固定：</p>
<table>
  <thead>
      <tr>
          <th>场景</th>
          <th>解法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>已知轨道数k</td>
          <td>直接按轨道折返规则还原明文</td>
      </tr>
      <tr>
          <td>未知轨道数k</td>
          <td>暴力枚举k在2到10之间（超过10无实际加密意义），通过自然语言可读性验证</td>
      </tr>
      <tr>
          <td>变体（列栅栏）</td>
          <td>按列数分组后反转列顺序（如k=2时，每2字符为一组交换位置）</td>
      </tr>
  </tbody>
</table>
<h3 id="23-python实现">
<a class="header-anchor" href="#23-python%e5%ae%9e%e7%8e%b0"></a>
2.3 Python实现
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 栅栏密码核心加解密</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">rail_fence_encrypt</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">rails</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">rails</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">text</span>
</span></span><span class="line"><span class="cl">    <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">rails</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ch</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">rails</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span> <span class="o">+=</span> <span class="n">step</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">rail_fence_decrypt</span><span class="p">(</span><span class="n">cipher</span><span class="p">,</span> <span class="n">rails</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">rails</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cipher</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cipher</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">rail_idx</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">rail_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">rails</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span> <span class="o">+=</span> <span class="n">step</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">rail_idx</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rails</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">rails_str</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">rails_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">c</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="n">start</span> <span class="o">+=</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">rail_idx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rails_str</span><span class="p">[</span><span class="n">rid</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 爆破示例</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">rail_fence_brute</span><span class="p">(</span><span class="n">cipher</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rail_fence_decrypt</span><span class="p">(</span><span class="n">cipher</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 测试</span>
</span></span><span class="line"><span class="cl"><span class="n">plain</span> <span class="o">=</span> <span class="s2">&#34;HELLOCRYPTO&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">cipher</span> <span class="o">=</span> <span class="n">rail_fence_encrypt</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;加密结果：&#34;</span><span class="p">,</span> <span class="n">cipher</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;解密结果：&#34;</span><span class="p">,</span> <span class="n">rail_fence_decrypt</span><span class="p">(</span><span class="n">cipher</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="24-常见陷阱ctf高频翻车点">
<a class="header-anchor" href="#24-%e5%b8%b8%e8%a7%81%e9%99%b7%e9%98%b1ctf%e9%ab%98%e9%a2%91%e7%bf%bb%e8%bd%a6%e7%82%b9"></a>
2.4 常见陷阱（CTF高频翻车点）
</h3><ol>
<li>明文含空格或标点：需确认题目要求保留或过滤（多数题目过滤非字母字符）；</li>
<li>轨道数大于等于明文长度：加密后密文与明文一致，无实际意义；</li>
<li>变体识别：部分题目标注栅栏密码但实际为列置换（需按列数分组反转）。</li>
</ol>
<p>参考资料：<a href="https://blog.csdn.net/Stone__Fly/article/details/53454418">栅栏密码原理与CTF实战</a></p>
        
        <hr><p>本文2025-12-02首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-02</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>Crypto入门-基于Windows操作系统的环境配置</title>
      <link>http://localhost:1336/post/crypto%E5%85%A5%E9%97%A8--%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 30 Nov 2025 13:37:02 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/crypto%E5%85%A5%E9%97%A8--%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</guid>
      <description>
        <![CDATA[<h1>Crypto入门-基于Windows操作系统的环境配置</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello!欢迎来到咪喵魔法世界~</p>
<p>抱着对crypto的强烈好奇与浓烈兴趣，我加入了这个神秘的魔法组织。有句话是这么说的，“当新鲜感褪去，真正的爱才开始浮现”。学习crypto的第四个月，我对这句话的赞同度只增不减。</p>
<p>不得不承认，crypto的学习也许不像第一眼看上去那样“炫酷”，它没有web“改个请求参数就能弹出 flag”的即时快乐；也没有二进制“调通断点让程序跑通”的爽感，学crypto的枯燥是越往深处走越磨人的“顿感枯燥”——不是基础RSA算逆元的机械，是分析复现 Coppersmith 算法攻击时对着 “短私钥多项式构造” 的论文啃一下午，连变量替换的逻辑都没摸透的头昏脑涨；是调 ECC 离散对数题时，对着椭圆曲线的加法法则算到脑仁疼，结果因为曲线参数是弱类型，之前的推演全成了无用功的哭笑不得；是面对无数 Latiice 文献的无从下手，或是左脑子进右脑子出的🤷‍♀️，以至于学到凌晨三更时总有摆烂的念头莫名生出。</p>
<p>然而幸运的是因为学习crypto，我结识了一群志同道合的朋友，认识了愿意带着我们做项目的老师，而我也感谢小小的老己从没想过放弃。</p>
<p>兴趣是指导一个人入门最好的老师，却并不足以支撑他长久的走下去。对我来说，支撑我啃这些枯燥文论的也从来不是 “有趣”，是那种 “慢半拍但沉甸甸” 的成就感；是想拥有一门 “别人替代不了” 的硬技能；是知道学会这些后能有更多的职业选择；甚至是在未来能够设计出一个自己的高安全性的加密程序 —— 这些朴素又真实的动力，比什么 “浪漫的坚持” 都更能让人沉下心，慢慢往前走。</p>
<p>如果你真正沉下心来学习crypto，你就会发现它其实是一门“入门易、精通难”的课程，核心是先把基础框架搭起来，再通过真题慢慢打磨。这篇文章是我整理的 CTF Crypto 前置学习笔记，目标是把「环境搭起来 + 基础语法能上手 + 工具链能跑通」做成一份可复用的操作清单。对于新手小白来说，照着做完，就能在本地拥有一个适合 CTF/Crypto 学习与实验的干净环境啦。</p>
<p>最后再次欢迎大家加入咪猫魔法部~或者一起来见证一只咪猫小cainiao的成长哈哈😄</p>
<hr>
<h2 id="一-环境配置目标以windows系统为例">
<a class="header-anchor" href="#%e4%b8%80-%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae%e7%9b%ae%e6%a0%87%e4%bb%a5windows%e7%b3%bb%e7%bb%9f%e4%b8%ba%e4%be%8b"></a>
一、 环境配置目标（以Windows系统为例）
</h2><p>在 crypto 的世界里，很多“题目做不出来”并不是你不聪明，而是——  <strong>环境没搭好、工具没装对、命令不会用、脚本跑不起来</strong>。</p>
<p>所以这篇文章我们不讲玄学，只讲<strong>把工坊搭好</strong>。不过由于都是最基础的环境配置问题，技术上没什么难点，主要就是跑时间和🖥️，所以我就不一一详细的讲解了，只给出必要的环境配置方向与步骤。（相关下载网址我放在文章最下端了，有需要的可以自取。）</p>
<p>✅ 你最终会拥有：</p>
<ul>
<li>Windows 电脑（主系统）</li>
<li>一个“藏在 Windows 里的 Linux”：WSL2（Ubuntu）</li>
<li>一个不会乱套的 Python 环境：Conda（crypto 专用环境）</li>
<li>一个适合数论/密码学的“超级计算器”：SageMath</li>
<li>一个边算边记边写报告的“魔法笔记本”：Jupyter Notebook</li>
<li>一个能编译 C 代码的工具链：gcc（在 WSL2 里）</li>
</ul>
<p>并且会跑通 2 个最小示例：</p>
<ul>
<li>Python 版凯撒密码 ✅</li>
<li>C 版凯撒密码 ✅</li>
</ul>
<p>如果上述目标你都已经达成了，就可以直接跳过这篇文章进入下一关：RSA / ECC / lattice / 等真题的复现啦。</p>
        
        <hr><p>本文2025-11-30首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-11-30</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
  </channel>
</rss>
