<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CTF Math 系列 on SWEET&#39;S BLOG</title>
    <link>http://localhost:1336/series/ctf-math-%E7%B3%BB%E5%88%97/</link>
    <description>Recent content from SWEET&#39;S BLOG</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    
    <managingEditor>1401617591@qq.com (sweet)</managingEditor>
    <webMaster>1401617591@qq.com (sweet)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Tue, 30 Dec 2025 14:30:00 +0800</lastBuildDate>
    
    
    <atom:link href="http://localhost:1336/series/ctf-math-%E7%B3%BB%E5%88%97/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>OpenSSL玩转X.509证书🐾</title>
      <link>http://localhost:1336/post/%E8%AF%81%E4%B9%A6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 30 Dec 2025 14:30:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E8%AF%81%E4%B9%A6%E6%93%8D%E4%BD%9C/</guid>
      <description>
        <![CDATA[<h1>OpenSSL玩转X.509证书🐾</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎回到咪猫魔法世界~ 🐾✨</p>
<p>上篇文章中我们学习了DH协议的身份验证，可新问题来了：Bob怎么可信地获取Alice的公钥？如果中间人伪造公钥，之前的安全逻辑不就崩塌了？这时候X.509证书就该登场啦！</p>
<p>本文主打一个“实操+踩坑实录”——精细拆解X.509证书格式、区分DER/PEM格式、用OpenSSL做证书解析/私钥解析/签名验证，同时夹杂为大家分享一些让我折腾良久的血泪踩坑经历，帮助大家更好的理解、掌握证书操作。</p>
<hr>
<h2 id="一x509证书让公钥可信的核心载体">
<a class="header-anchor" href="#%e4%b8%80x509%e8%af%81%e4%b9%a6%e8%ae%a9%e5%85%ac%e9%92%a5%e5%8f%af%e4%bf%a1%e7%9a%84%e6%a0%b8%e5%bf%83%e8%bd%bd%e4%bd%93"></a>
一、X.509证书：让公钥“可信”的核心载体
</h2><p>X.509是公钥基础设施（PKI）的数字证书标准，核心使命就是解决“公钥可信分发”——通过可信第三方（CA）的签名，担保“实体身份 ↔ 公钥”的绑定关系，让接收方放心使用公钥。</p>
<h3 id="11-证书的核心组成rsa场景">
<a class="header-anchor" href="#11-%e8%af%81%e4%b9%a6%e7%9a%84%e6%a0%b8%e5%bf%83%e7%bb%84%e6%88%90rsa%e5%9c%ba%e6%99%af"></a>
1.1 证书的核心组成（RSA场景）
</h3><p>X.509证书本质是“身份信息+公钥+CA签名”的组合包，关键部分如下：</p>
<ol>
<li><strong>身份与有效期</strong>：
<ul>
<li>颁发者（Issuer）：谁签的证书（比如“某根CA机构”）；</li>
<li>主体（Subject）：证书属于谁（比如“www.example.com服务器”）；</li>
<li>有效期：证书生效和过期时间，过期后失效。</li>
</ul>
</li>
<li><strong>公钥与算法（RSA核心）</strong>：
<ul>
<li>公钥算法：明确使用RSA；</li>
<li>公钥内容：包含RSA的模数n和公指数e（常用65537），是加密/签名的核心参数。</li>
</ul>
</li>
<li><strong>CA的数字签名</strong>：
CA用自己的私钥，对“身份、公钥、有效期”等信息签名。其他人用CA的公钥验证签名，就能确认“证书未被篡改，公钥确实属于这个主体”。</li>
</ol>
<blockquote>
<p>咪猫小知识：CA（Certificate Authority）是受信任的证书颁发机构，比如百度HTTPS证书由GlobalSign颁发，我们常用的SSL证书都来自这类权威机构。</p>
</blockquote>
<h3 id="12-典型应用场景https通信">
<a class="header-anchor" href="#12-%e5%85%b8%e5%9e%8b%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%afhttps%e9%80%9a%e4%bf%a1"></a>
1.2 典型应用场景（HTTPS通信）
</h3><ol>
<li>服务器向客户端发送X.509证书；</li>
<li>客户端验证证书：CA签名是否合法、有效期是否有效、域名是否匹配；</li>
<li>验证通过后，客户端用证书中的RSA公钥加密“预主密钥”；</li>
<li>服务器用自身RSA私钥解密，双方基于预主密钥生成会话密钥，安全通信。</li>
</ol>
<hr>
<h2 id="二der与pem证书的两种存储格式">
<a class="header-anchor" href="#%e4%ba%8cder%e4%b8%8epem%e8%af%81%e4%b9%a6%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ad%98%e5%82%a8%e6%a0%bc%e5%bc%8f"></a>
二、DER与PEM：证书的两种“存储格式”
</h2><p>DER和PEM不是证书内容的区别，而是“存储X.509二进制数据”的两种方式，实际操作中经常要切换，必须要分清奥！</p>
<h3 id="21-格式核心对比">
<a class="header-anchor" href="#21-%e6%a0%bc%e5%bc%8f%e6%a0%b8%e5%bf%83%e5%af%b9%e6%af%94"></a>
2.1 格式核心对比
</h3><table>
  <thead>
      <tr>
          <th>对比项</th>
          <th>DER 格式</th>
          <th>PEM 格式</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>编码方式</td>
          <td>二进制直接存储</td>
          <td>Base64编码（转成可打印文本）</td>
      </tr>
      <tr>
          <td>可读性</td>
          <td>二进制，文本编辑器打开是乱码</td>
          <td>文本格式，可直接阅读，开头/结尾有固定标记</td>
      </tr>
      <tr>
          <td>固定标记</td>
          <td>无</td>
          <td>开头：<code>-----BEGIN CERTIFICATE-----</code>；结尾：<code>-----END CERTIFICATE-----</code>（私钥/签名有对应标记）</td>
      </tr>
      <tr>
          <td>典型场景</td>
          <td>系统内部、程序间二进制交互</td>
          <td>文本环境传输（配置文件、邮件）、OpenSSL常用</td>
      </tr>
  </tbody>
</table>
<h3 id="22-关键提醒">
<a class="header-anchor" href="#22-%e5%85%b3%e9%94%ae%e6%8f%90%e9%86%92"></a>
2.2 关键提醒
</h3><ul>
<li>后缀不绝对：.cer/.crt可能是DER或PEM格式，需根据编码判断；</li>
<li>转换方法：OpenSSL可实现两种格式互转（后面实操会讲）。</li>
</ul>
<hr>
<h2 id="三openssl实操证书解析私钥解析签名验证">
<a class="header-anchor" href="#%e4%b8%89openssl%e5%ae%9e%e6%93%8d%e8%af%81%e4%b9%a6%e8%a7%a3%e6%9e%90%e7%a7%81%e9%92%a5%e8%a7%a3%e6%9e%90%e7%ad%be%e5%90%8d%e9%aa%8c%e8%af%81"></a>
三、OpenSSL实操：证书解析+私钥解析+签名验证
</h2><p>证书操作的核心工具是OpenSSL，下面的操作完全基于实际踩坑经历，步骤清晰，直接照做就行！</p>
<h3 id="31-准备工作">
<a class="header-anchor" href="#31-%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c"></a>
3.1 准备工作
</h3><ul>
<li>安装OpenSSL：Windows下载Win64 OpenSSL，安装后配置环境变量（或直接在安装目录的bin文件夹打开命令行）；</li>
<li>准备文件：获取证书文件（如rsa_private.pem），确保文件完整（避免多余字符）。</li>
</ul>
<h3 id="32-核心操作命令win64环境">
<a class="header-anchor" href="#32-%e6%a0%b8%e5%bf%83%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4win64%e7%8e%af%e5%a2%83"></a>
3.2 核心操作命令（Win64环境）
</h3><h4 id="1-解析rsa私钥pem格式">
<a class="header-anchor" href="#1-%e8%a7%a3%e6%9e%90rsa%e7%a7%81%e9%92%a5pem%e6%a0%bc%e5%bc%8f"></a>
1. 解析RSA私钥（PEM格式）
</h4><p>命令：</p>
        
        <hr><p>本文2025-12-30首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-30</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>维纳攻击(Wiener&#39;s Attack)🐾</title>
      <link>http://localhost:1336/post/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/</link>
      <pubDate>Sun, 28 Dec 2025 15:30:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/</guid>
      <description>
        <![CDATA[<h1>维纳攻击(Wiener's Attack)🐾</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎回到咪猫魔法世界~ 🐾✨</p>
<p>RSA的安全看似靠“大数分解”撑着，但如果私钥d选得太短，就会被维纳攻击轻松破解！本文专门拆解了维纳攻击的核心逻辑——用连分数逼近找到短小的d，不用分解n就能直接拿到私钥（cool），并在文末给出了完整代码和CTF例题，全程带着“踩坑实录”，帮新来的师傅们搞懂“为什么d短了就不安全”。</p>
<p>我们之前已经了解过了 RSA 的各种攻击，而维纳攻击算是“剑走偏锋”的一种，核心依赖数论里的连分数工具，看似复杂，实则思路超清晰——不过如果我们能掌握“连分数+收敛子验证”，这类题也是能拿下的。</p>
<hr>
<h2 id="一前置知识连分数维纳攻击的核心工具">
<a class="header-anchor" href="#%e4%b8%80%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e8%bf%9e%e5%88%86%e6%95%b0%e7%bb%b4%e7%ba%b3%e6%94%bb%e5%87%bb%e7%9a%84%e6%a0%b8%e5%bf%83%e5%b7%a5%e5%85%b7"></a>
一、前置知识：连分数——维纳攻击的核心工具
</h2><p>维纳攻击的本质是“用连分数逼近有理数”，所以先搞懂连分数的基础，攻击原理就顺理成章了。</p>
<h3 id="11-连分数的定义">
<a class="header-anchor" href="#11-%e8%bf%9e%e5%88%86%e6%95%b0%e7%9a%84%e5%ae%9a%e4%b9%89"></a>
1.1 连分数的定义
</h3><p>连分数是一种特殊的分数表示形式，通过整数与单位分数（分子为1的分数）递归嵌套表达，比如正分数\(a/b\)可展开为：
</p>
\[
x = a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \frac{1}{a_3 + \ddots}}}
\]<p>
简记为\([a_0; a_1, a_2, ..., a_k]\)，其中\(a_0\)是整数部分，\(a_1,a_2,...,a_k\)是正整数“部分商”。</p>
<p>举个例子：\(11/35\)的连分数展开为\([0; 3, 5, 2]\)，计算过程如下：</p>
<ol>
<li>\(35 ÷ 11 = 3\) 余 \(2\) → 部分商\(a_0=0\)，剩余\(2/11\)；</li>
<li>\(11 ÷ 2 = 5\) 余 \(1\) → 部分商\(a_1=3\)，剩余\(1/2\)；</li>
<li>\(2 ÷ 1 = 2\) 余 \(0\) → 部分商\(a_2=5\)，\(a_3=2\)，终止。</li>
</ol>
<h3 id="12-连分数的核心概念收敛子">
<a class="header-anchor" href="#12-%e8%bf%9e%e5%88%86%e6%95%b0%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e6%94%b6%e6%95%9b%e5%ad%90"></a>
1.2 连分数的核心概念：收敛子
</h3><p>收敛子是“截取连分数前n项部分商”得到的近似分数，记为\(h_n/m_n\)（\(h_n\)为分子，\(m_n\)为分母）。它的关键性质是：</p>
<ul>
<li>逼近精度随项数增加而提高，交替大于、小于原分数；</li>
<li>是原分数的“最优逼近”——没有分母更小的分数能比收敛子更接近原分数。</li>
</ul>
<p>比如\(11/35\)的收敛子：</p>
        
        <hr><p>本文2025-12-28首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-28</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>密钥交换的魔法：DH协议与STS协议🐾</title>
      <link>http://localhost:1336/post/dh%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 25 Dec 2025 16:00:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/dh%E5%8D%8F%E8%AE%AE/</guid>
      <description>
        <![CDATA[<h1>密钥交换的魔法：DH协议与STS协议🐾</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎回到咪猫魔法世界~ 🐾✨</p>
<p>在不安全的网络里，怎么安全交换只有双方知道的共享密钥？这就轮到DH协议登场啦！它能在被监听的信道上，让通信双方算出相同的密钥，却让窃听者无从下手——核心秘诀就是“离散对数难题”的魔力~o( =∩ω∩= )m～</p>
<p>本文专门拆解DH协议的基础原理、中间人攻击的漏洞，以及简化STS协议的防护方案，还给出了可直接运行的Python代码，全程保持“边学边踩坑”的真实感，帮助各位新手师傅们搞懂密钥交换的核心逻辑！</p>
<hr>
<h2 id="一dh协议基础不安全信道的密钥魔法">
<a class="header-anchor" href="#%e4%b8%80dh%e5%8d%8f%e8%ae%ae%e5%9f%ba%e7%a1%80%e4%b8%8d%e5%ae%89%e5%85%a8%e4%bf%a1%e9%81%93%e7%9a%84%e5%af%86%e9%92%a5%e9%ad%94%e6%b3%95"></a>
一、DH协议基础：不安全信道的密钥魔法
</h2><p>DH协议（Diffie-Hellman协议）是密钥交换的经典方案，1976年由Whitfield Diffie和Martin Hellman提出，核心是“公开参数+私有计算”，让双方在不泄露私钥的情况下，协商出共享密钥。</p>
<h3 id="11-核心原理离散对数难题">
<a class="header-anchor" href="#11-%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e7%a6%bb%e6%95%a3%e5%af%b9%e6%95%b0%e9%9a%be%e9%a2%98"></a>
1.1 核心原理：离散对数难题
</h3><p>DH协议的安全性完全依赖“离散对数问题”的困难性：</p>
<ul>
<li>已知大素数p、模p的本原根g（g的幂能生成模p的所有非零剩余类），以及 \(g^a \pmod{p}\)，想反推出私钥a，在p足够大时几乎不可能（暴力破解无效）；</li>
<li>正向计算很简单：已知a，计算 \(g^a \pmod{p}\) 高效可行。</li>
</ul>
<h3 id="12-dh协议流程基础原始版">
<a class="header-anchor" href="#12-dh%e5%8d%8f%e8%ae%ae%e6%b5%81%e7%a8%8b%e5%9f%ba%e7%a1%80%e5%8e%9f%e5%a7%8b%e7%89%88"></a>
1.2 DH协议流程（基础原始版）
</h3><h4 id="文字版步骤">
<a class="header-anchor" href="#%e6%96%87%e5%ad%97%e7%89%88%e6%ad%a5%e9%aa%a4"></a>
文字版步骤：
</h4><ol>
<li>公开参数协商：双方先约定公开参数——大素数p和模p的本原根g（可公开传输，无需保密）；</li>
<li>私钥生成：
<ul>
<li>Alice生成私钥a（保密），计算公钥 \(A = g^a \pmod{p}\)，发给Bob；</li>
<li>Bob生成私钥b（保密），计算公钥 \(B = g^b \pmod{p}\)，发给Alice；</li>
</ul>
</li>
<li>共享密钥计算：
<ul>
<li>Alice用Bob的公钥B和自己的私钥a，计算 \(K = B^a \pmod{p} = (g^b)^a \pmod{p} = g^{ab} \pmod{p}\)；</li>
<li>Bob用Alice的公钥A和自己的私钥b，计算 \(K = A^b \pmod{p} = (g^a)^b \pmod{p} = g^{ab} \pmod{p}\)；</li>
</ul>
</li>
<li>结果：双方得到相同的共享密钥K，窃听者仅能获取p、g、A、B，无法推导K。</li>
</ol>
<h4 id="原理图解">
<a class="header-anchor" href="#%e5%8e%9f%e7%90%86%e5%9b%be%e8%a7%a3"></a>
原理图解：
</h4><pre tabindex="0"><code>Alice                  不安全信道                  Bob
  |                        |                        |
  |  生成私钥a，计算A=g^a mod p                  |
  |-------------------------------------------&gt;|
  |                        |                        |
  |                                          生成私钥b，计算B=g^b mod p
  |&lt;-------------------------------------------|
  |                        |                        |
  |  计算K=B^a mod p                          |
  |                        |                        |  计算K=A^b mod p
  |                        |                        |
  |  共享密钥K                                  共享密钥K
  |                        |                        |
</code></pre><h3 id="13-python代码实现">
<a class="header-anchor" href="#13-python%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0"></a>
1.3 Python代码实现
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">dh_simulate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">alice_a</span><span class="p">,</span> <span class="n">bob_b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 分别生成Alice和Bob的公钥</span>
</span></span><span class="line"><span class="cl">    <span class="n">alice_A</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">alice_a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">bob_B</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">bob_b</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 分别计算Alice和Bob的共享密钥</span>
</span></span><span class="line"><span class="cl">    <span class="n">alice_shared</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">bob_B</span><span class="p">,</span> <span class="n">alice_a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">bob_shared</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">alice_A</span><span class="p">,</span> <span class="n">bob_b</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 验证双方计算出的共享密钥是否一致</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 若共享密钥不一致，说明可能遭受中间人攻击，模拟失败</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">alice_shared</span> <span class="o">==</span> <span class="n">bob_shared</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">alice_shared</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 手动输入p、g、alice_a、bob_b（可替换为大素数和大私钥）</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="mi">23</span>  <span class="c1"># 模素数（实际应用需用2048位以上大素数）</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># 模23的本原根（5的幂能生成1~22所有数）</span>
</span></span><span class="line"><span class="cl"><span class="n">alice_a</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Alice的私钥（保密）</span>
</span></span><span class="line"><span class="cl"><span class="n">bob_b</span> <span class="o">=</span> <span class="mi">15</span>   <span class="c1"># Bob的私钥（保密）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">shared_key</span> <span class="o">=</span> <span class="n">dh_simulate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">alice_a</span><span class="p">,</span> <span class="n">bob_b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;公共参数:p=</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">, g=</span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Alice的私钥:</span><span class="si">{</span><span class="n">alice_a</span><span class="si">}</span><span class="s2">, 公钥:</span><span class="si">{</span><span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">alice_a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Bob的私钥:</span><span class="si">{</span><span class="n">bob_b</span><span class="si">}</span><span class="s2">, 公钥:</span><span class="si">{</span><span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">bob_b</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;共享密钥:</span><span class="si">{</span><span class="n">shared_key</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="运行结果">
<a class="header-anchor" href="#%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c"></a>
运行结果：
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">公共参数</span><span class="p">:</span><span class="n">p</span><span class="o">=</span><span class="mi">23</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">Alice的私钥</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="n">公钥</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="n">Bob的私钥</span><span class="p">:</span><span class="mi">15</span><span class="p">,</span> <span class="n">公钥</span><span class="p">:</span><span class="mi">19</span>
</span></span><span class="line"><span class="cl"><span class="n">共享密钥</span><span class="p">:</span><span class="mi">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="二致命漏洞中间人攻击如何破解dh协议">
<a class="header-anchor" href="#%e4%ba%8c%e8%87%b4%e5%91%bd%e6%bc%8f%e6%b4%9e%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e7%a0%b4%e8%a7%a3dh%e5%8d%8f%e8%ae%ae"></a>
二、致命漏洞：中间人攻击如何破解DH协议？
</h2><p>基础DH协议看似完美，但有个致命缺陷——<strong>缺乏身份验证</strong>，中间人能轻松篡改公钥，窃取通信内容！</p>
        
        <hr><p>本文2025-12-25首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-25</p>]]>
      </description>
      
        <category>ctf-crypto</category>
      
    </item>
    
    

    <item>
      <title>二次剩余与勒让德符号🐾</title>
      <link>http://localhost:1336/post/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E%E5%8B%92%E8%AE%A9%E5%BE%B7%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Mon, 22 Dec 2025 15:30:00 &#43;0800</pubDate>
      <author>1401617591@qq.com (sweet)</author>
      <guid>http://localhost:1336/post/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E%E5%8B%92%E8%AE%A9%E5%BE%B7%E7%AC%A6%E5%8F%B7/</guid>
      <description>
        <![CDATA[<h1>二次剩余与勒让德符号🐾</h1><p>作者：sweet（1401617591@qq.com）</p>
        
          <h2 id="引言">
<a class="header-anchor" href="#%e5%bc%95%e8%a8%80"></a>
引言
</h2><p>hello！欢迎回到咪猫魔法世界~ 🐾✨</p>
<p>信安人绕不开的“数论坎”来啦！前面学完一次同余方程，本以为可以顺风顺水，结果碰到二次同余直接懵圈——怎么一次到二次，解法复杂度直接翻倍啊？！</p>
<p>这篇blog是上一篇《信安数学基础学习与练习》的专项补强，专门拆解二次同余方程、二次剩余、勒让德符号这些“拦路虎”，还会和一次同余做详细对比，帮大家理清逻辑。全程保持真实踩坑感，毕竟“懂（不）了”才是学习数论的常态嘛！</p>
<hr>
<h2 id="一二次同余方程从一次到二次解法的蜕变">
<a class="header-anchor" href="#%e4%b8%80%e4%ba%8c%e6%ac%a1%e5%90%8c%e4%bd%99%e6%96%b9%e7%a8%8b%e4%bb%8e%e4%b8%80%e6%ac%a1%e5%88%b0%e4%ba%8c%e6%ac%a1%e8%a7%a3%e6%b3%95%e7%9a%84%e8%9c%95%e5%8f%98"></a>
一、二次同余方程：从一次到二次解法的“蜕变”
</h2><blockquote>
<p>一次同余方程靠扩展欧几里得就能直接冲，可二次同余完全不一样！核心逻辑是“拆解+合并”，先把复杂模数拆成简单素数幂，解完再用中国剩余定理合并，一步都不能省。</p>
</blockquote>
<h3 id="11-二次同余方程核心原理">
<a class="header-anchor" href="#11-%e4%ba%8c%e6%ac%a1%e5%90%8c%e4%bd%99%e6%96%b9%e7%a8%8b%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86"></a>
1.1 二次同余方程核心原理
</h3><p>二次同余方程的一般形式是 \(ax^2 + bx + c \equiv 0 \pmod{m}\)，最简形式是 \(x^2 \equiv a \pmod{m}\)（a、m为整数，\(m>0\)）。</p>
<p>核心思路就两步：</p>
<ol>
<li>模数分解：根据“素数幂分解定理”，把m拆成 \(m = p_1^{k_1} \times p_2^{k_2} \times ... \times p_n^{k_n}\)（\(p_i\) 是素数）；</li>
<li>合并解：原方程等价于“模每个素数幂 \(p_i^{k_i}\) 的同余方程组”，解完每个方程组后，用中国剩余定理合并出最终解。</li>
</ol>
<blockquote>
<p>Q: 为啥要这么拆？
A: 直接解模合数m的方程太难了！素数幂的方程更简单，拆解后难度直接降级🐱</p>
</blockquote>
<h3 id="12-一次-vs-二次同余方程">
<a class="header-anchor" href="#12-%e4%b8%80%e6%ac%a1-vs-%e4%ba%8c%e6%ac%a1%e5%90%8c%e4%bd%99%e6%96%b9%e7%a8%8b"></a>
1.2 一次 vs 二次同余方程
</h3><p>为了避免混淆，我把两者的关键差异整理成了表格，一目了然：</p>
<table>
  <thead>
      <tr>
          <th>对比维度</th>
          <th>一次同余方程</th>
          <th>二次同余方程</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>方程形式</td>
          <td>\(ax \equiv b \pmod{m}\)（a、m为整数，\(m>0\)）</td>
          <td>一般形式：\(ax^2 + bx + c \equiv 0 \pmod{m}\)；最简形式：\(x^2 \equiv a \pmod{m}\)</td>
      </tr>
      <tr>
          <td>解的存在性判断</td>
          <td>简单！计算\(\gcd(a,m)\)，若能整除b则有解</td>
          <td>复杂！先拆m为素数幂，再用勒让德符号/欧拉判别法判断每个素数幂下是否有解，最后看所有方程组是否都有解</td>
      </tr>
      <tr>
          <td>核心解法工具</td>
          <td>1. 扩展欧几里得算法（求特解）；2. 中国剩余定理（合并解）</td>
          <td>1. 勒让德/雅可比符号（判断可解性）；2. 亨泽尔引理（提升素数解到素数幂解）；3. Tonelli-Shanks算法（求素数模下的解）；4. 中国剩余定理（合并解）</td>
      </tr>
      <tr>
          <td>解的数量与结构</td>
          <td>若有解，设\(d=\gcd(a,m)\)，则模m下有d个不同解；解的结构：\(x \equiv x_0 + k \times m/d \pmod{m}\)（\(k=0,1,...,d-1\)），规律明确</td>
          <td>模素数p（\(p \nmid a\)）：有解则通常2个解；\(x^2 \equiv 0 \pmod{p}\) 仅有1个解\(x \equiv 0\)；模素数幂\(p^k\)：解数可能为0、1或2；模合数m：解数是各素数幂解数的乘积，无统一规律</td>
      </tr>
      <tr>
          <td>复杂度与应用</td>
          <td>复杂度低，直接用于RSA求模逆元等场景</td>
          <td>复杂度高，依赖大数分解；二次剩余的判断困难性是Goldwasser-Micali概率加密的安全基础，求解算法（如Tonelli-Shanks）用于椭圆曲线密码</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="二二次剩余平方同余有解的专属名字">
<a class="header-anchor" href="#%e4%ba%8c%e4%ba%8c%e6%ac%a1%e5%89%a9%e4%bd%99%e5%b9%b3%e6%96%b9%e5%90%8c%e4%bd%99%e6%9c%89%e8%a7%a3%e7%9a%84%e4%b8%93%e5%b1%9e%e5%90%8d%e5%ad%97"></a>
二、二次剩余：平方同余有解的“专属名字”
</h2><p>搞懂二次同余，核心就是搞懂“二次剩余”——本质就是判断“\(x^2 \equiv a \pmod{p}\) 有没有解”</p>
        
        <hr><p>本文2025-12-22首发于<a href='http://localhost:1336/'>SWEET'S BLOG</a>，最后修改于2025-12-22</p>]]>
      </description>
      
        <category>ctf-math</category>
      
    </item>
    
  </channel>
</rss>
